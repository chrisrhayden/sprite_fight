use std::{collections::HashMap, fs::File};

use rusttype::{gpu_cache::Cache, point, Font, PositionedGlyph, Scale};

// use unicode_normalization::char::compose;
// use unicode_normalization::UnicodeNormalization;

use sdl2::{
    pixels::PixelFormatEnum,
    rect::Rect,
    render::{Texture, TextureCreator},
    surface::Surface,
    video::WindowContext,
};

use crate::tileset::Tileset;

const ASCII: &'static str = " !\"#$%&'()\
*+,-./0123\
456789:;<=\
>?@ABCDEFG\
HIJKLMNOPQ\
RSTUVWXYZ[\
\\]^_`abcde\
fghijklmno\
pqrstuvwxy\
z{|}~";

// fn make_ascii() {
//     for (i, not_char) in (32u8..127u8).enumerate() {
//         if i > 0 && i % 10 == 0 {
//             println!("\\");
//         }
//
//         print!("{}", not_char as char);
//     }
//     println!();
//
//     println!("{}", ASCII);
// }

pub struct RTFontCache<'tex, 'font> {
    pub font_data: Font<'font>,
    pub cache: Cache<'font>,
    pub texture: Texture<'tex>,

    font_w: u32,
    font_h: u32,

    glyphs: HashMap<char, PositionedGlyph<'font>>,
}

impl<'tex, 'font> RTFontCache<'tex, 'font> {
    pub fn new(texture_creator: &'tex TextureCreator<WindowContext>) -> Self {
        use std::io::Read;
        let scale = Scale::uniform(8.0);
        let mut glyphs = HashMap::new();

        let mut fl = File::open("assets/ttf/unscii-16-full.ttf").unwrap();

        let mut buf = Vec::new();

        fl.read_to_end(&mut buf).unwrap();

        let font_data = match Font::try_from_vec(buf) {
            Some(f_data) => f_data,
            None => {
                panic!("no font i guess");
            }
        };

        let v_metrics = font_data.v_metrics(scale);

        let mut cache = Cache::builder().build();

        let mut point = point(0.0, v_metrics.ascent);

        for c in ASCII.chars() {
            let g = font_data.glyph(c).scaled(scale).positioned(point);

            cache.queue_glyph(0, g.clone());

            glyphs.insert(c, g);

            point.x += 8.0;
        }

        let (w, h) = cache.dimensions();

        let surfance = Surface::new(w, h, PixelFormatEnum::RGB24).unwrap();

        let mut texture = texture_creator
            .create_texture_from_surface(surfance)
            .unwrap();

        cache.cache_queued(|region, data| {
            let rect = Rect::new(
                region.min.x as i32,
                region.max.y as i32,
                region.min.x + region.max.x,
                region.min.y + region.max.y,
            );

            texture.update(rect, data, 0);
        });

        Self {
            font_w: 8,
            font_h: 8,
            font_data,
            cache,
            texture,
            glyphs,
        }
    }
}

impl<'tex, 'font> Tileset<'tex, '_> for RTFontCache<'tex, 'font> {
    fn get_char(&mut self, to_get: char) -> (&mut Texture<'tex>, Rect) {
        let g = self.glyphs.get(&to_get).unwrap();

        let (uv_rect, _screen_rect) =
            self.cache.rect_for(0, g).unwrap().unwrap();

        let x = uv_rect.min.x as i32;
        let y = uv_rect.max.y as i32;

        let w = (uv_rect.min.x + uv_rect.max.x) as u32;
        let h = (uv_rect.min.y + uv_rect.max.y) as u32;

        let sdl_rect = Rect::new(x, y, w, h);

        (&mut self.texture, sdl_rect)
    }

    fn width(&self) -> u32 {
        self.font_w
    }

    fn height(&self) -> u32 {
        self.font_h
    }
}
